Langkah - langkah implementasi: Pertama, saya membuat repositori baru bernama dudushop di file explorer. Setelah itu, saya mengaktifkan environment untuk Django dan menginstall beberapa library yang berada di requirements.txt. Setelah direktori sudah siap, saya membuat aplikasi Django bernama main, lalu membuat model Shop yang berisi informasi terkait produk seperti nama, harga, deskripsi, thumbnail, is_featured dan kategori. Model ini saya buat dengan menggunakan struktur data yang umum dipakai pada aplikasi e-commerce.

Setelah membuat model, saya membuat fungsi view show_main di views.py untuk merender halaman utama (main.html). Fungsi ini menggunakan render() dan mengirimkan context berisi nama toko, nama saya, dan kelas. View ini kemudian dihubungkan dengan URL melalui urls.py dengan path kosong ('') yang nantinya akan muncul di root URL aplikasi.

Saya juga membuat file main.html sebagai template HTML yang menggunakan context dari view untuk menampilkan data secara dinamis. Template ini menggunakan sintaks Django seperti {{ shop }} dan {{ name }} untuk menampilkan data yang dikirim dari view.

Berikut cara kerja program : dari urls.py (path('', show_main, name='show_main')), ke views.py (def show_main(request): ...) ke models.py (class Shop(models.Model): ...), dan terakhir ke main.html

Request masuk melalui urls.py, diteruskan ke fungsi show_main di views.py, yang kemudian bisa mengambil data dari models.py (tetapi untuk saat ini models belum digunakan, mungkin untuk tugas berikutnya). Terakhir, fungsi ini merender main.html dan mengembalikan hasilnya ke client.

Peran settings.py dalam Proyek Django File settings.py berfungsi sebagai pusat pengaturan proyek, mulai dari pengaturan database, daftar aplikasi yang digunakan (INSTALLED_APPS), path template, pengaturan static files, secret key, debugging, hingga konfigurasi untuk deployment. Tanpa file ini, Django tidak bisa mengetahui bagaimana dan di mana harus menjalankan aplikasinya.

Cara Kerja Migrasi Database di Django Migrasi database di Django adalah proses untuk menyinkronkan struktur model Python ke dalam struktur database yang sebenarnya. Proses ini terbagi menjadi 2 langkah, yaitu: python manage.py makemigrations : Membuat file migrasi berdasarkan perubahan di model (models.py). python manage.py migrate : Menerapkan file migrasi ke database dan mengubah tabel sesuai dengan model yang sudah dibuat.

Django sangat cocok untuk pemula karena dokumentasinya lengkap dan mudah dipahami, selain itu Django menggunakan bahasa python yang mudah dimengerti sebagai pemula. Terutama untuk mahasiswa yang biasa nya telah belajar bahasa python di semester awal. Lalu django juga menggunakan prinsip "batteries included", sehingga banyak fitur sudah tersedia tanpa perlu menginstall nya lagi. Struktur proyek django juga rapi dan jelas untuk dipahami sebagai pemula. Jadi dengan menggunakan Django, kita bisa langsung mencoba membangun aplikasi web nyata tanpa perlu memahami semua detail teknis dari awal.

Feedback untuk Asisten Dosen Asisten dosen telah banyak membantu ketika tutorial, dan juga telah sabar menghadapi masalah-masalah yang cukup unik pada masing-masing mahasiswa. Asisten dosen juga membantu semua mahasiswa di kelas agar dapat selesai tepat waktu. Terimakasi

------------------------------------------------------------------------------------------------

Data delivery penting dalam pengembangan sebuah platform karena agar platform dapat melakukan pertukaran data antara server dan client secara terstruktur dan aman. Dengan adanya data delivery, aplikasi bisa diakses oleh berbagai perangkat dengan cara yang sama, contohnya website dan mobile app. Tanpa data delivery yang baik, pertukaran informasi akan terganggu sehingga platform tidak dapat berjalan secara optimal. Selain itu, data delivery juga memungkinkan integrasi antar modul, mendukung skalabilitas, serta meningkatkan pengalaman pengguna.

Menurut saya, XML dan JSON sama-sama merupakan pilihan yang bagus. XML memiliki struktur yang lebih kompleks dan mendukung metadata dalam bentuk tag, sehingga cocok untuk dokumen dengan hierarki yang dalam. Tapi, JSON jauh lebih populer saat ini karena sintaksnya lebih sederhana, ukurannya lebih kecil, mudah dipahami oleh kita, dan juga langsung didukung oleh JavaScript. JSON juga dapat diproses lebih cepat oleh kebanyakan bahasa pemrograman, sehingga lebih efisien dalam performa aplikasi. Maka untuk saat ini, saya merasa JSON lebih cocok untuk penggunaan saya.

metode is_valid() berfungsi untuk mem validasi data yang dimasukkan oleh pengguna. Metode ini memastikan setiap data sesuai dengan aturan, seperti panjang karakter, tipe data, dan syarat lain yang sudah ditentukan. Jika data valid, maka bisa disimpan ke database. Jika tidak valid, program akan memberikan pesan error yang ditampilkan ke pengguna. Tanpa metode ini, aplikasi rentan mendapatkan input yang salah maupun berbahaya, seperti injection atau data kosong yang tidak seharusnya tidak bisa diterima.

csrf_token ini mencegah serangan Cross-Site Request Forgery (CSRF), yaitu kondisi ketika penyerang memanfaatkan sesi login user untuk mengirimkan request palsu tanpa sepengetahuan usernya sendiri. Dengan adanya csrf_token, setiap form yang dikirim akan diperiksa apakah berasal dari aplikasi asli atau bukan. Jika token tidak ada atau tidak valid, maka request akan ditolak. Dengan token ini, penyerang tidak bisa membuat link atau script berbahaya yang mengeksploitasi akun user.

Penjelasan step by step ketika membuat program:
Pertama, saya menambahkan empat fungsi di views.py untuk menampilkan data dalam format XML, JSON dan juga XML by ID dan JSON by ID. Langkah pembuatannya sama seperti yang dijelaskan di tutorial sebelumnya. Selain itu, saya juga menambahkan dua fungsi baru yaitu add_product untuk menambahkan produk dan detail_product untuk melihat detail produk. Hasil dari data produk disimpan di product_list. Setelah itu, saya menambahkan beberapa path di urls.py sesuai dengan method yang sudah dibuat di views.py. Saya juga membuat template HTML untuk halaman tambah produk (add_product) dan detail produk (detail_product), saya juga menambahkan base.html seperti pada tutorial sebelumnya. Saya juga membuat ShopForm di forms.py yang berisi field name, price, description, thumbnail, category, dan is_featured. Dengann program ini, saya sudah membuat fitur add_product di website saya dan juga fitur detail produk yang dapat menampilkan data dari masing-masing produk yang dipilih.

Feedback untuk Asisten Dosen:
Tutorial sudah jelas dan bisa diikuti, waktu yang diberikan juga cukup untuk menyelesaikan tutorial tersebut. kakak asdos juga sangat membantu ketika ditanya. terimakasih.

------------------------------------------------------------------------------------------------

Django AuthenticationForm adalah form bawaan Django yang digunakan untuk proses login pengguna. Form ini secara otomatis menyediakan tempat untuk username dan password, dan juga melakukan validasi terhadap data yang dimasukkan dengan memeriksa ke database apakah user valid. Kelebihan dari AuthenticationForm adalah memudahkan developer karena sudah menyediakan logika autentikasi dasar, sehingga tidak perlu menulis ulang dari nol. Selain itu, form ini sudah terintegrasi dengan sistem keamanan Django, seperti password hashing. Kekurangannya, fleksibilitasnya terbatas karena hanya mendukung field standar, jika aplikasi memerlukan field tambahan atau kustomisasi lebih kompleks, maka developer perlu melakukan override.

Autentikasi adalah proses untuk memverifikasi identitas pengguna, biasanya melalui username dan password. Otorisasi adalah proses untuk menentukan hak akses pengguna setelah identitasnya diverifikasi. Django mengimplementasikan autentikasi melalui django.contrib.auth, yang menangani login, logout, dan manajemen user. Untuk otorisasi, Django menyediakan sistem permission dan group yang menentukan hak akses pada model atau view.

Session dan cookies sama-sama digunakan untuk menyimpan state di aplikasi web. Cookies disimpan di sisi client (browser) sehingga memungkinkan client membawa data kecil pada setiap request ke server. Kelebihannya, cookies sederhana dan langsung bisa digunakan tanpa perlu penyimpanan tambahan di server, tetapi kekurangannya adalah rentan dapat dimodifikasi oleh client jika tidak diamankan dengan baik. Session disimpan di sisi server, sementara browser hanya menyimpan session ID dalam bentuk cookie. Kelebihan session adalah lebih aman karena data penting tidak tersimpan di sisi client, namun kekurangannya memerlukan manajemen tambahan di server dan dapat meningkatkan beban penyimpanan.

Penggunaan cookies tidak sepenuhnya aman, karena ada risiko seperti pencurian cookies melalui serangan XSS (Cross-Site Scripting) atau session hijacking. Django menangani hal ini dengan menyediakan opsi keamanan seperti HttpOnly untuk mencegah akses cookie melalui JavaScript, Secure agar cookie hanya dikirim melalui HTTPS, serta CSRF token untuk mencegah serangan Cross-Site Request Forgery. 

Implementasi Step-by-Step
Pertama, buat view register yang menyimpan User bila form.is_valid(), buat template register.html, dan masukkan URL path('register/', register, name='register'). Lalu tambahkan fungsi login dengan mengimpor AuthenticationForm, authenticate, dan login, buat view login_user yang memvalidasi AuthenticationForm, memanggil login(request, user) saat valid, buat login.html, dan daftarkan URL path('login/', login_user, name='login'). Tambahkan fungsi logout dengan buat logout_user yang memanggil logout(request) lalu redirect ke halaman login, tambahkan tombol Logout pada main.html, dan daftarkan URL untuk logout. 

Lalu kita batasi akses beberapa halaman dengan @login_required(login_url='/login') di atas show_main dan add_product, sehingga hanya user yang sudah login yang dapat mengakses halaman tersebut, pada login_user kembalikan HttpResponseRedirect dan panggil response.set_cookie('last_login', str(datetime.datetime.now())); ambil di show_main dengan request.COOKIES.get('last_login','Never'); dan hapus cookie itu saat logout. Ini membuat informasi waktu login terakhir tampil di halaman utama. 

Hubungkan model Shop dengan User dengan menambahkan user = models.ForeignKey(User, on_delete=models.CASCADE, null=True) pada model Shop, lalu makemigrations dan migrate; setelah itu filter berita berdasarkan request.user agar tiap pengguna melihat hanya artikelnya sendiri.